% Generated by roxygen2 (4.0.2): do not edit by hand
\name{rollply}
\alias{rollply}
\title{Rollply}
\usage{
rollply(.data, .rollvars, wdw.size, fun, mesh = NULL, mesh.res = 200,
  mesh.type = "grid_identical", mesh.options = NULL, padding = "none",
  .parallel = FALSE, ...)
}
\arguments{
\item{.data}{data.frame to be processed}

\item{.rollvars}{variables describing the moving window: a formula of the
form ~ a + b | c, where a and b denote the variables used
for the rolling window and c an eventual grouping}

\item{wdw.size}{window size}

\item{fun}{function to apply to each piece}

\item{mesh}{data.frame of points at which the computation is done}

\item{mesh.res}{if mesh is unspecified, then the number of points for the
resolution of the mesh to build. Otherwise ignored.}

\item{padding}{padding policy outside of data range, one of 'none',
'outside', 'inside', or a numeric value}

\item{.parallel}{whether to use parallel processing (see \link{ddply} for
more information on parallelism).}

\item{...}{other arguments passed to ddply and fun}
}
\description{
For each subset of a data.frame falling in a moving window, computes the
results of a function on this subset, then combine results in a data.frame.
}
\details{
Rollply uses internally ddply on the provided or automatically built mesh.
The mesh can be predefined
}
\examples{
# Generate 1D random walk
dat <- data.frame(time=seq.int(1000),
                  position=cumsum(rnorm(1000,0,10)))

rollav <- rollply(dat, ~ time, wdw.size=10,
                  summarise, position=mean(position))

plot(position ~ time, data=dat)
lines(rollav, col='red')


# see http://github.com/alexgenin/rollply for more examples
}


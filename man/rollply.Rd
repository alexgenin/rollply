% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rollply.R
\name{rollply}
\alias{rollply}
\title{Rollply}
\usage{
rollply(.data, .rollvars, wdw.size, fun, grid = NULL, grid_npts = NULL,
  grid_type = "identical", grid_opts = NULL, padding = "none",
  .parallel = FALSE, ...)
}
\arguments{
\item{.data}{\code{data.frame} to be processed}

\item{.rollvars}{a formula of the form \code{~ a + b + ... | c} describing over
which variables the window should move. \code{a} and \code{b} denote the 
variables used for the rolling window and \code{c} an optional grouping 
variable.}

\item{wdw.size}{window size}

\item{fun}{function to apply}

\item{grid}{data.frame of points at which the computation is done. If
\code{NULL} then a grid is generated using \code{grid_npts} and 
\code{grid_type}.}

\item{grid_npts}{if grid is unspecified, the number of points of the 
grid to build.}

\item{grid_type}{The type of grid to generate (one of "squaretile", 
"identical", "ahull_crop", "ahull_fill").}

\item{grid_opts}{A list of named options to be passed to the grid-generating
function.}

\item{padding}{padding policy at the edges of the dataset, one of 'none',
'outside', 'inside', or a numeric value}

\item{.parallel}{whether to use parallel processing (see \code{\link{ddply}}
for more information on parallelism).}

\item{...}{other arguments passed to \code{\link{ddply}} and \code{fun}}
}
\value{
A data.frame with the function results at each grid point. Make sure the 
  function results are fit for merging into a data.frame (i.e. that they can 
  be merged using \code{\link[plyr]{rbind.fill}}).
}
\description{
Apply a function in a moving window then combine the results 
  in a data.frame.
}
\details{
rollply applies a function in a window moving over one or more variables. It
is built upon \code{\link{ddply}} so it inherits many of its useful options
'such as \code{.parallel} or \code{.progress}.

Rollply uses internally a grid spanning the coordinates specified in the
formula. For each point of this grid, it then selects the corresponding
subset of the data frame within \code{wdw.size}, and pass it to the
function \code{fun}. The return values of \code{fun} are then combined into 
a data frame.

If specified, the grid should have column names matching the ones provided 
  in the left-hand side of the formula. If the grid is unspecified, then 
  rollply automatically computes an appropriate grid depending on the option 
  \code{grid_type}: 
  
  \itemize{
    \item "identical" Creates a grid with an identical number of points on 
      each dimension. 
    \item "squaretile" Creates a grid with square tiles (points are 
      equidistant on all dimensions)
    \item "ahull_crop" Creates a grid with square tiles, then crop the 
      result to the alpha hull of the set of points
    \item "ahull_fill" Same as above, but iteratively tries to return a grid 
      with a number of points similar to what was requests using 
      \code{grid_npts}
   }

Each of these grid types correspond to a function with prefix 
  \code{build_grid}. Some of them have options that can be passed by 
  providing a named list as argument \code{grid_opts}.

The padding argument indicates what to do at the edges of the dataset. A 
  value of "inside" indicates that no value will be computed when the window
  is not entirely contained within the range of the dataset. This parameter
  does not apply to alphahull-based grids.
}
\examples{

library(plyr)

# 1D example: make a trendline for a time-series
dat <- data.frame(time     = seq.int(1000),
                  position = cumsum(rnorm(1000,0,10)))

rollav <- rollply(dat, ~ time, wdw.size=10,
                  summarise, position=mean(position))

plot(position ~ time, data = dat, pch = 20)
lines(rollav, col = 'red', lwd = 3)

# 2D example

# Generate three 2D random walks
dat <- ddply(data.frame(person = c('francois','nicolas','jacques')), 
             ~ person,
             summarise, time = seq.int(1000),
                        x    = cumsum(rnorm(1000,0,1)),
                        y    = cumsum(rnorm(1000,0,1)))

# Smoothed trajectory over ten time-steps
rollav <- rollply(dat, ~ time | person, wdw.size = 10, grid_res = 1000,
                  summarise, x = mean(x), y = mean(y))

if ( require(ggplot2) ) {
  ggplot(dat, aes(x, y, color = person)) +
    geom_point(alpha = .5, shape = '+') +
    geom_path(data = rollav)
}

# Where did people spend their time ?
# we pregenerate the grid to fix it across groups
fixed_grid <- build_grid_squaretile(dat[ ,c('x','y')], 2000) 
rollav <- rollply(dat, ~ x + y | person, wdw.size = 2, grid = fixed_grid,
                  summarise, time.spent = length(time))

if ( require(ggplot2) ) {
  ggplot(subset(rollav, time.spent > 0)) +
    geom_point(aes(x, y, color = person, size = time.spent), alpha = .5) +
    facet_grid(~person)
}


}
\seealso{
build_grid_identical, build_grid_squaretile, build_grid_ahull_crop, 
  build_grid_ahull_fill
}

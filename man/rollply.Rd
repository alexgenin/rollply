% Generated by roxygen2 (4.0.2): do not edit by hand
\name{rollply}
\alias{rollply}
\title{Rollply}
\usage{
rollply(.data, .rollvars, wdw.size, fun, mesh = NULL, mesh.res = 200,
  mesh.type = "grid_identical", mesh.options = NULL, padding = "none",
  .parallel = FALSE, ...)
}
\arguments{
\item{.data}{data.frame to be processed}

\item{.rollvars}{variables describing the moving window: a formula of the
form ~ a + b | c, where a and b denote the variables used
for the rolling window and c an eventual grouping}

\item{wdw.size}{window size}

\item{fun}{function to apply to each piece}

\item{mesh}{mesh of points at which the moving window is evaluated}

\item{mesh.res}{if mesh is unspecified, then the number of points for the
resolution of the default mesh to build. Otherwise ignored.}

\item{padding}{padding policy outside of data range, one of 'none',
'outside', 'inside', or a numeric value}

\item{.parallel}{whether to use parallel processing (see \link{ddply} for
more information on parallelism)}

\item{...}{other arguments passed first to ddply and/or adply, then to fun}
}
\description{
For each subset of a data.frame falling in a moving window, computes the
results of a function on this subset, then combine results in a data.frame.
}
\details{
Fill in.
}
\examples{
library(ggplot2)
library(plyr)

# Generate 1D random walk
dat <- data.frame(time=seq.int(1000),
                  position=cumsum(rnorm(1000,0,10)))

rollav <- rollply(dat, ~ time, wdw.size=10,
                  summarise, position=mean(position))

ggplot(NULL,aes(time,position)) +
  geom_point(data=dat) +
  geom_line(color='red', data=rollav)
}

